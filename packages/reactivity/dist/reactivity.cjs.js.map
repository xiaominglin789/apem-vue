{"version":3,"file":"reactivity.cjs.js","sources":["../../shared/src/index.ts","../src/enum.ts","../src/effect.ts","../src/base-handler.ts","../src/reactive.ts"],"sourcesContent":["/** 共享模块-通用方法集合 */\n\n/**\n * 判断data是否为对象类型\n * @param data \n * @returns true: 是对象类型,  false: 非对象类型\n */\nfunction isObject(data: any): boolean {\n  let flag = false;\n  if (Object.prototype.toString.call(data) === \"[object Object]\") {\n    flag = true;\n  }\n  \n  return flag;\n}\n\n\nexport {\n  isObject\n};\n","/** 依赖收集的操作标识枚举 */\nexport enum TrackOpsEnum {\n  /** 取值 */\n  GET,\n}","import { TrackOpsEnum } from \"./enum\";\n\n/** 配置项参数定义 */\ninterface IEffectOptions {\n  /** 是否为懒加载 */\n  lazy: boolean\n}\n\n/** effect序号标识 */\nlet effectID = 0;\n/** 当前的effect */\nlet activeEffect = null;\n/** effect存储栈 */\nconst effectStack = [];\n/**\n * 对象-属性-effects 依赖映射表\n * 结构:-WeakMap(-Map(-Set))\n * {\n *    target: {\n *      key: Set(effect1, effect2)\n *    }\n * }\n */\nconst targetEffectMap = new WeakMap();\n\n/**\n * 副作用\n * 作用: 可响应的effect, 数据变化时重新执行\n * @param fn 函数\n * @param options 配置对象:key-value\n */\nfunction effect(fn: Function, options: IEffectOptions = { lazy: false }) {\n  const effect = createReactiveEffect(fn, options);\n\n  if (!options.lazy) {\n    // 默认先执行一次\n    effect();\n  }\n\n  return effect;\n}\n\n/** 创建可响应的efflect函数 - 闭包 */\nfunction createReactiveEffect(fn: Function, options: IEffectOptions = { lazy: false }) {\n  const effect = function reactiveEffect() {\n    // 函数执行, 会取值, 会执行reactive的get方法作依赖收集\n    if (!effectStack.includes(effect)) {\n      try {\n        console.log(\"准备执行effect内的函数\");\n        effectStack.push(effect);\n        activeEffect = effect;\n        return fn();\n      } finally {\n        // 遇到嵌套effect函数时，保证 activeEffect 正确指向\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  }\n\n  // 当前effect的id标识\n  effect.id = effectID++;\n  // 标记为 响应式的effect\n  effect._isEffect = true;\n  // effect-对应的原函数\n  effect.raw = fn;\n  // effect-属性配置\n  effect.options = options;\n\n  return effect;\n}\n\n/**\n * 依赖收集函数\n * 让 某个对象的属性,收集其当前对应的effect函数。\n * @param target 目标对象\n * @param trackOpType 操作标识\n * @param key 对象的属性\n */\nfunction track(target: object, trackOpType: TrackOpsEnum, key: string) {\n  // console.log(\"收集到依赖 \", target, \" \", key);\n  // console.log(target, key, activeEffect);\n  if (null === activeEffect) {\n    return;\n  }\n\n  let depsMap = targetEffectMap.get(target);\n  if (!depsMap) {\n    // 空map,初始化taget键\n    targetEffectMap.set(target, (depsMap = new Map))\n  }\n\n  let dep = depsMap.get(key);\n  if (!dep) {\n    // 空vulue-map,初始化set\n    depsMap.set(key, (dep = new Set));\n  }\n\n  // set去重effect\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n  }\n\n  console.log(targetEffectMap);\n}\n\nexport {\n  effect,\n  track\n}\n","import { isObject } from \"@vue/shared\";\nimport { readonly, reactive } from \"./reactive\";\nimport { TrackOpsEnum } from \"./enum\";\nimport { track } from \"./effect\";\n\n/** 响应式对象-get */\nconst get = createGetter(false, false);\n/** 仅第一层响应式对象-get */\nconst shollawReactiveGetter = createGetter(false, true);\n/** 全部属性仅读对象-get */\nconst readonlyGetter = createGetter(true, false);\n/** 仅第一层只读对象-get */\nconst shollawReadonlyGetter = createGetter(true, true);\n/** 响应式对象-set */\nconst set = createSetter(false);\n/** 仅第一层响应式对象-set */\nconst shollawReactiveSetter = createSetter(true);\n\n/**\n * getter读取\n * @param isReadonly 是否为仅读, true: readonly仅读, false: 响应式proxy\n * @param isShollaw 是否为仅作用于第一层, true: 仅作用于第一层， false: 全部嵌套属性都仅读或响应式\n * @returns \n */\nfunction createGetter(isReadonly=false, isShollaw=false) {\n  return function get(target: object, key: string, recevier: object) {\n    const result = Reflect.get(target, key, recevier);\n\n    if (!isReadonly) {\n      // 只读的对象不做依赖收集\n      // 响应式对象-才作依赖收集\n      // 取值时, 去 执行 tract 收集 effect\n      // v3 effect =取代了=>  v2 watcher\n      console.log(\"执行effect时会取值， 需要收集effect: \", key);\n      track(target, TrackOpsEnum.GET, key);\n    }\n\n    if (isShollaw) {\n      // 只有第一层是响应式属性\n      return result;\n    } \n    \n    if (isObject(result)) {\n      // 当取值时才进行代理\n      // 判断对象类型，只读属性，递归包装\n      return isReadonly ? readonly(result) : reactive(result);\n    }\n\n    return result;\n  }\n}\n\n/**\n * setter写入(只有响应式数据才能修改)\n * @param isShollaw 是否为仅作用于第一层, true: 仅作用于第一层， false: 全部嵌套属性都响应式\n */\nfunction createSetter(isShollaw=false) {\n  return function set(target: object, key: string, newValue: any, recevier: object) {\n    const result = Reflect.set(target, key, newValue, recevier);\n    \n    if (isShollaw) {\n      // true\n    } else {\n      // false\n    }\n\n\n    return result;\n  }\n}\n\n/** reactive包装-get/set处理 */\nconst handleReactive = {\n  get,\n  set,\n}\n\n/** shallowReactive包装-get/set处理 */\nconst handleShollawReactive = {\n  get: shollawReactiveGetter,\n  set: shollawReactiveSetter\n}\n\n/** readonly包装-get/set处理 */\nconst handleReadonly = {\n  get: readonlyGetter,\n  set: (target: object, key: string) => {\n    console.warn(target, \" 所有属性都是只读, 无法修改\");\n    return false;\n  }\n}\n\n/** shallowReadonly包装-get/set处理 */\nconst handleShollawReadonly = {\n  get: shollawReadonlyGetter,\n  set: (target: object, key: string) => {\n    console.warn(target, \" 的属性:\", key, \" 属性是只读的, 无法修改\");\n    return false;\n  }\n}\n\nexport {\n  handleReactive,\n  handleShollawReactive,\n  handleReadonly,\n  handleShollawReadonly,\n}\n","import { isObject } from \"@vue/shared/src\";\nimport {\n  handleReactive,\n  handleShollawReactive,\n  handleReadonly,\n  handleShollawReadonly,\n} from \"./base-handler\";\n\n/** 响应式数据-代理对象map */\nconst reactiveProxyMap = new WeakMap();\n/** 只读数据-代理对象map */\nconst readonlyProxyMap = new WeakMap();\n\n/**\n * 根据配置创建代理对象\n * @param target 数据源\n * @param isReadonly 是否仅读\n * @param handle get/set-处理配置项\n */\nfunction createReactiveObject(target: object, isReadonly: boolean, handle: ProxyHandler<object>) {\n  /**\n   * 1.数据源是不是对象类型, 非对象的数据源直接返回\n   * 2.数据源是否已被代理过了,有代理则直接返回代理的数据\n   *   - 数据源是不是只读的, 取到对应的数据缓存\n   *   - 没有缓存,则存入缓存中、\n   */\n  if (!isObject(target)) {\n    return target;\n  }\n\n  const proxyMap = isReadonly ? readonlyProxyMap : reactiveProxyMap;\n\n  if (proxyMap.has(target)) {\n    // 有缓存, 返回缓存\n    return proxyMap.get(target);\n  }\n\n  // 无缓存, 先存缓存\n  const targetProxy = new Proxy(target, handle);\n  proxyMap.set(target, targetProxy);\n\n  return targetProxy;\n}\n\n\n/** reactive包装: 所有深度的属性都被包装成proxy */\nfunction reactive(data: any) {\n  return createReactiveObject(data, false, handleReactive);\n}\n\n/** shallowReactive包装: 只有第一层属性会被包装成proxy,其他层不会 */\nfunction shallowReactive(data: any) {\n  return createReactiveObject(data, false, handleShollawReactive);\n}\n\n/** readonly包装: 所有属性都是只读,不能改 */\nfunction readonly(data: any) {\n  return createReactiveObject(data, true, handleReadonly);\n}\n\n/**\n * shallowReadonly包装: 只有第一层属性是只读的,其他层的可读可改\n */\nfunction shallowReadonly(data: any) {\n  return createReactiveObject(data, true, handleShollawReadonly);\n}\n\nexport {\n  reactive,\n  shallowReactive,\n  readonly,\n  shallowReadonly\n};\n"],"names":[],"mappings":"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"}